# -*- coding: utf-8 -*-
"""NASA Battery Aging Analysis.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1njMUl9HoAkGWR4HKV5oHS3XHejIodoF2
"""

pip install plotly

import numpy as np
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go

df=pd.read_csv('metadata.csv')
df.head()

# Filtering out dataset with type impedance and also creating original dataframe of dataset
impedance_df = df[df['type'] == 'impedance'][['start_time', 'Re', 'Rct', 'battery_id']]
dataset_df = df[df['type'] == 'impedance'][['start_time', 'filename', 'battery_id']]

# Converting start time to appropriate format
from datetime import datetime

def parse_start_time(value):
    try:
        if isinstance(value, str):
            value = value.strip("[]").replace(",", "")
            components = [float(x) for x in value.split()]
            if len(components) == 6:
                year, month, day, hour, minute = map(int, components[:5])
                second = int(components[5])
                return datetime(year, month, day, hour, minute, second)
    except (ValueError, SyntaxError, TypeError):
        return pd.NaT
    return pd.NaT

# Parsing start time in both datasets
dataset_df['start_time'] = dataset_df['start_time'].apply(parse_start_time)
impedance_df['start_time'] = impedance_df['start_time'].apply(parse_start_time)

# Dropping null values and sorting based on start time
impedance_df = impedance_df.dropna(subset=['start_time'])
impedance_df = impedance_df.sort_values(by='start_time')

dataset_df = dataset_df.dropna(subset=['start_time'])
dataset_df = dataset_df.sort_values(by='start_time')

# Printing list of batteries in dat
print(impedance_df['battery_id'].unique())

# EDA: Boxplot to compare Re and Rct across battery IDs
fig = px.box(
    impedance_df,
    x='battery_id',
    y='Re',
    title="Interactive Re Across Different Battery IDs",
    color='battery_id'
)
fig.update_layout(
    xaxis_title="Battery ID",
    yaxis_title="Re (Ohms)",
    boxmode='group',
    hovermode="x unified"
)
fig.show()

fig = px.box(
    impedance_df,
    x='battery_id',
    y='Rct',
    title="Interactive Rct Across Different Battery IDs",
    color='battery_id'
)
fig.update_layout(
    xaxis_title="Battery ID",
    yaxis_title="Rct (Ohms)",
    boxmode='group',
    hovermode="x unified"
)
fig.show()

# EDA: Scatter plot to analyze relationship between Re and Rct
fig = px.scatter(
    impedance_df,
    x='Re',
    y='Rct',
    color='battery_id',
    title="Interactive Re vs Rct for Different Battery IDs",
    labels={'Re': 'Ohmic Resistance (Re)', 'Rct': 'Charge Transfer Resistance (Rct)'},
    hover_data=['battery_id'],
    color_continuous_scale='Viridis'
)
fig.update_layout(
    legend_title_text="Battery ID",
    hovermode="closest"
)
fig.show()

for battery_id in impedance_df['battery_id'].unique() :
    current_battery_info = impedance_df[impedance_df['battery_id'] == battery_id]
    # print(current_battery_info)
    fig = go.Figure()
    fig.add_trace(go.Scatter(
        x=current_battery_info['start_time'],
        y=current_battery_info['Re'],
        mode='lines',
        name='Re',
        line=dict(color='orange')
    ))
    fig.add_trace(go.Scatter(
        x=current_battery_info['start_time'],
        y=current_battery_info['Rct'],
        mode='lines',
        name='Rct',
        line=dict(color='blue')
    ))
    fig.update_layout(
        title=f"Resistance (Battery ID: {battery_id})",
        xaxis_title="Start Time",
        yaxis_title="Resistance (Ohms)",
        xaxis=dict(tickangle=45),
        legend_title="Legend",
        template="plotly"
    )
    fig.show()